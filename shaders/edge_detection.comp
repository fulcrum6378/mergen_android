#version 450
#extension GL_ARB_separate_shader_objects : enable
//https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt

#define H 720u
#define W 720u
#define WORKGROUP_SIZE 18u
// maxComputeWorkGroupInvocations in Mali G72 => 384

layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1u) in;
// use `std430` instead of `std140` for the data structure to match that of C++.
layout(std430, binding = 0) readonly buffer bufI {
    uint arr[H][W];
};
layout(std430, binding = 1) buffer bufO {
    bool statuses[H][W];
};

bool compareColours(uint a, uint b) {
    return abs(float(a >> 16) - float(b >> 16)) <= 4.0f &&
        abs(float(int(a >> 8) & 0xFF) - float(int(b >> 8) & 0xFF)) <= 4.0f &&
        abs(float(int(a) & 0xFF) - float(int(b) & 0xFF)) <= 4.0f;
}

void main() {
    uint x = gl_GlobalInvocationID.x, y = gl_GlobalInvocationID.y;
    // in order to fit the work into workgroups, some unnecessary threads are launched.
    // we terminate those threads here.
    if (x >= W || y >= H) return;
    // std140:
    //if ((W * y + x) > 130046u) return; // max 518400
    // weird that the maximum safe index changed from 130047u to 130046u when I fixed that bug;
    // making `arr` have different values rather than all zero.
    // changing the data type to `uint` didn't change the maximum!

    bool nt = y != 0, nb = y != H - 1,
         nl = x != 0, nr = x != W - 1;
    if (nt && compareColours(arr[y][x], arr[y - 1][x])) { // top
        statuses[y][x] = true;
        return;
    }
    if (nt && nr && compareColours(arr[y][x], arr[y - 1][x + 1])) { // top-right
        statuses[y][x] = true;
        return;
    }
    if (nr && compareColours(arr[y][x], arr[y][x + 1])) { // right
        statuses[y][x] = true;
        return;
    }
    if (nb && nr && compareColours(arr[y][x], arr[y + 1][x + 1])) { // bottom-right
        statuses[y][x] = true;
        return;
    }
    if (nb && compareColours(arr[y][x], arr[y + 1][x])) { // bottom
        statuses[y][x] = true;
        return;
    }
    if (nb && nl && compareColours(arr[y][x], arr[y + 1][x - 1])) { // bottom-left
        statuses[y][x] = true;
        return;
    }
    if (nl && compareColours(arr[y][x], arr[y][x - 1])) { // left
        statuses[y][x] = true;
        return;
    }
    if (nt && nl && compareColours(arr[y][x], arr[y - 1][x - 1])) { // top-left
        statuses[y][x] = true;
        return;
    }
    statuses[y][x] = false;
}
